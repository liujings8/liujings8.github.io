{"meta":{"title":"phantomliu's blog","subtitle":null,"description":"不只是一个码农","author":"phantomliu","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-01-21T03:50:06.000Z","updated":"2018-01-21T03:50:06.710Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-01-20T09:38:54.000Z","updated":"2018-01-21T08:10:43.872Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-01-21T08:17:34.000Z","updated":"2018-01-21T08:17:59.835Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"schedule","date":"2018-01-21T08:29:45.000Z","updated":"2018-01-21T08:29:45.389Z","comments":true,"path":"schedule/index.html","permalink":"http://yoursite.com/schedule/index.html","excerpt":"","text":""}],"posts":[{"title":"面试官最爱的volatile关键字","slug":"面试官最爱的volatile关键字","date":"2018-01-22T15:08:32.000Z","updated":"2018-01-22T18:14:39.663Z","comments":true,"path":"2018/01/22/面试官最爱的volatile关键字/","link":"","permalink":"http://yoursite.com/2018/01/22/面试官最爱的volatile关键字/","excerpt":"在Java相关的岗位面试中，很多面试官都喜欢考察面试者对Java并发的了解程度，而以volatile关键字作为一个小的切入点，往往可以一问到底，把Java内存模型（JMM），Java并发编程的一些特性都牵扯出来，深入地话还可以考察JVM底层实现以及操作系统的相关知识。","text":"在Java相关的岗位面试中，很多面试官都喜欢考察面试者对Java并发的了解程度，而以volatile关键字作为一个小的切入点，往往可以一问到底，把Java内存模型（JMM），Java并发编程的一些特性都牵扯出来，深入地话还可以考察JVM底层实现以及操作系统的相关知识。 下面我们以一次假想的面试过程，来深入了解下volitile关键字吧 面试官: Java并发这块了解的怎么样？说说你对volatile关键字的理解就我理解的而言，被volatile修饰的共享变量，就具有了以下两点特性： 1 . 保证了不同线程对该变量操作的内存可见性; 2 . 禁止指令重排序 面试官: 能不能详细说下什么是内存可见性，什么又是重排序呢？这个聊起来可就多了，我还是从Java内存模型说起吧。Java虚拟机规范试图定义一种Java内存模型（JMM）,来屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果。简单来说，由于CPU执行指令的速度是很快的，但是内存访问的速度就慢了很多，相差的不是一个数量级，所以搞处理器的那群大佬们又在CPU里加了好几层高速缓存。 在Java内存模型里，对上述的优化又进行了一波抽象。JMM规定所有变量都是存在主存中的，类似于上面提到的普通内存，每个线程又包含自己的工作内存，方便理解就可以看成CPU上的寄存器或者高速缓存。所以线程的操作都是以工作内存为主，它们只能访问自己的工作内存，且工作前后都要把值在同步回主内存。 这么说得我自己都有些不清楚了，拿张纸画一下： 在线程执行时，首先会从主存中read变量值，再load到工作内存中的副本中，然后再传给处理器执行，执行完毕后再给工作内存中的副本赋值，随后工作内存再把值传回给主存，主存中的值才更新。 使用工作内存和主存，虽然加快的速度，但是也带来了一些问题。比如看下面一个例子：1i = i + 1; 假设i初值为0，当只有一个线程执行它时，结果肯定得到1，当两个线程执行时，会得到结果2吗？这倒不一定了。可能存在这种情况：123456线程1： load i from 主存 // i = 0 i + 1 // i = 1线程2： load i from主存 // 因为线程1还没将i的值写回主存，所以i还是0 i + 1 //i = 1线程1: save i to 主存线程2： save i to 主存 如果两个线程按照上面的执行流程，那么i最后的值居然是1了。如果最后的写回生效的慢，你再读取i的值，都可能是0，这就是缓存不一致问题。 下面就要提到你刚才问到的问题了，JMM主要就是围绕着如何在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的，通过解决这三个问题，可以解除缓存不一致的问题。而volatile跟可见性和有序性都有关。 面试官：那你具体说说这三个特性呢？1 . 原子性(Atomicity)：Java中，对基本数据类型的读取和赋值操作是原子性操作，所谓原子性操作就是指这些操作是不可中断的，要做一定做完，要么就没有执行。 比如：1234i = 2;j = i;i++;i = i + 1； 上面4个操作中，i=2是读取操作，必定是原子性操作，j=i你以为是原子性操作，其实吧，分为两步，一是读取i的值，然后再赋值给j,这就是2步操作了，称不上原子操作，i++和i = i + 1其实是等效的，读取i的值，加1，再写回主存，那就是3步操作了。所以上面的举例中，最后的值可能出现多种情况，就是因为满足不了原子性。 这么说来，只有简单的读取，赋值是原子操作，还只能是用数字赋值，用变量的话还多了一步读取变量值的操作。有个例外是，虚拟机规范中允许对64位数据类型(long和double)，分为2次32为的操作来处理，但是最新JDK实现还是实现了原子操作的。 JMM只实现了基本的原子性，像上面i++那样的操作，必须借助于synchronized和Lock来保证整块代码的原子性了。线程在释放锁之前，必然会把i的值刷回到主存的。 2 . 可见性(Visibility)： 说到可见性，Java就是利用volatile来提供可见性的。当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主存，当其它线程需要读取该变量时，会去内存中读取新值。而普通变量则不能保证这一点。 其实通过synchronized和Lock也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存，但是synchronized和Lock的开销都更大。 3 . 有序性（Ordering） JMM是允许编译器和处理器对指令重排序的，但是规定了as-if-serial语义，即不管怎么重排序，程序的执行结果不能改变。比如下面的程序段：123double pi = 3.14; //Adouble r = 1; //Bdouble s= pi * r * r;//C 上面的语句，可以按照A-&gt;B-&gt;C执行，结果为3.14,但是也可以按照B-&gt;A-&gt;C的顺序执行，因为A、B是两句独立的语句，而C则依赖于A、B，所以A、B可以重排序，但是C却不能排到A、B的前面。JMM保证了重排序不会影响到单线程的执行，但是在多线程中却容易出问题。 比如这样的代码:1234567891011121314int a = 0;bool flag = false;public void write() &#123; a = 2; //1 flag = true; //2&#125;public void multiply() &#123; if (flag) &#123; //3 int ret = a * a;//4 &#125; &#125; 假如有两个线程执行上述代码段，线程1先执行write，随后线程2再执行multiply，最后ret的值一定是4吗？结果不一定： 如图所示，write方法里的1和2做了重排序，线程1先对flag赋值为true，随后执行到线程2，ret直接计算出结果，再到线程1，这时候a才赋值为2,很明显迟了一步。 这时候可以为flag加上volatile关键字，禁止重排序，可以确保程序的“有序性”，也可以上重量级的synchronized和Lock来保证有序性,它们能保证那一块区域里的代码都是一次性执行完毕的。 另外，JMM具备一些先天的有序性,即不需要通过任何手段就可以保证的有序性，通常称为happens-before原则。&lt;&lt;JSR-133：Java Memory Model and Thread Specification&gt;&gt;定义了如下happens-before规则： 1程序顺序规则： 一个线程中的每个操作，happens-before于该线程中的任意后续操作2.监视器锁规则：对一个线程的解锁，happens-before于随后对这个线程的加锁3.volatile变量规则： 对一个volatile域的写，happens-before于后续对这个volatile域的读4.传递性：如果A happens-before B ,且 B happens-before C, 那么 A happens-before C5.start()规则： 如果线程A执行操作ThreadB_start()(启动线程B) , 那么A线程的ThreadB_start()happens-before 于B中的任意操作6.join()原则： 如果A执行ThreadB.join()并且成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。7.interrupt()原则： 对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生8.finalize()原则：一个对象的初始化完成先行发生于它的finalize()方法的开始 第1条规则程序顺序规则是说在一个线程里，所有的操作都是按顺序的，但是在JMM里其实只要执行结果一样，是允许重排序的，这边的happens-before强调的重点也是单线程执行结果的正确性，但是无法保证多线程也是如此。 第2条规则监视器规则其实也好理解，就是在加锁之前，确定这个锁之前已经被释放了，才能继续加锁。 第3条规则，就适用到所讨论的volatile，如果一个线程先去写一个变量，另外一个线程再去读，那么写入操作一定在读操作之前。 第4条规则，就是happens-before的传递性。 后面几条就不再一一赘述了。 面试官：volatile关键字如何满足并发编程的三大特性的？那就要重提volatile变量规则： 对一个volatile域的写，happens-before于后续对这个volatile域的读。这条再拎出来说，其实就是如果一个变量声明成是volatile的，那么当我读变量时，总是能读到它的最新值，这里最新值是指不管其它哪个线程对该变量做了写操作，都会立刻被更新到主存里，我也能从主存里读到这个刚写入的值。也就是说volatile关键字可以保证可见性以及有序性。 继续拿上面的一段代码举例：1234567891011121314int a = 0;bool flag = false;public void write() &#123; a = 2; //1 flag = true; //2&#125;public void multiply() &#123; if (flag) &#123; //3 int ret = a * a;//4 &#125; &#125; 这段代码不仅仅受到重排序的困扰，即使1、2没有重排序。3也不会那么顺利的执行的。假设还是线程1先执行write操作，线程2再执行multiply操作，由于线程1是在工作内存里把flag赋值为1，不一定立刻写回主存，所以线程2执行时，multiply再从主存读flag值，仍然可能为false，那么括号里的语句将不会执行。 如果改成下面这样：12345678910111213int a = 0;volatile bool flag = false;public void write() &#123; a = 2; //1 flag = true; //2&#125;public void multiply() &#123; if (flag) &#123; //3 int ret = a * a;//4 &#125;&#125; 那么线程1先执行write,线程2再执行multiply。根据happens-before原则，这个过程会满足以下3类规则： 程序顺序规则：1 happens-before 2; 3 happens-before 4; (volatile限制了指令重排序，所以1 在2 之前执行)volatile规则：2 happens-before 3传递性规则：1 happens-before 4 从内存语义上来看当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。 面试官：volatile的两点内存语义能保证可见性和有序性，但是能保证原子性吗？首先我回答是不能保证原子性，要是说能保证，也只是对单个volatile变量的读/写具有原子性，但是对于类似volatile++这样的复合操作就无能为力了，比如下面的例子：12345678910111213141516171819202122public class Test &#123; public volatile int inc = 0; public void increase() &#123; inc++; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125; 按道理来说结果是10000，但是运行下很可能是个小于10000的值。有人可能会说volatile不是保证了可见性啊，一个线程对inc的修改，另外一个线程应该立刻看到啊！可是这里的操作inc++是个复合操作啊，包括读取inc的值，对其自增，然后再写回主存。 假设线程A，读取了inc的值为10，这时候被阻塞了，因为没有对变量进行修改，触发不了volatile规则。 线程B此时也读读inc的值，主存里inc的值依旧为10，做自增，然后立刻就被写回主存了，为11。 此时又轮到线程A执行，由于工作内存里保存的是10，所以继续做自增，再写回主存，11又被写了一遍。所以虽然两个线程执行了两次increase()，结果却只加了一次。 有人说，volatile不是会使缓存行无效的吗？但是这里线程A读取到线程B也进行操作之前，并没有修改inc值，所以线程B读取的时候，还是读的10。 又有人说，线程B将11写回主存，不会把线程A的缓存行设为无效吗？但是线程A的读取操作已经做过了啊，只有在做读取操作时，发现自己缓存行无效，才会去读主存的值，所以这里线程A只能继续做自增了。 综上所述，在这种复合操作的情景下，原子性的功能是维持不了了。但是volatile在上面那种设置flag值的例子里，由于对flag的读/写操作都是单步的，所以还是能保证原子性的。 要想保证原子性，只能借助于synchronized,Lock以及并发包下的atomic的原子操作类了，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。 面试官：说的还可以，那你知道volatile底层的实现机制？如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。 lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能： 1 . 重排序时不能把后面的指令重排序到内存屏障之前的位置2 . 使得本CPU的Cache写入内存3 . 写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见。 面试官： 你在哪里会使用到volatile，举两个例子呢？1.状态量标记，就如上面对flag的标记，我重新提一下：12345678910111213int a = 0;volatile bool flag = false;public void write() &#123; a = 2; //1 flag = true; //2&#125;public void multiply() &#123; if (flag) &#123; //3 int ret = a * a;//4 &#125;&#125; 这种对变量的读写操作，标记为volatile可以保证修改对线程立刻可见。比synchronized,Lock有一定的效率提升。 2.单例模式的实现，典型的双重检查锁定（DCL）1234567891011121314151617class Singleton&#123; private volatile static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance==null) &#123; synchronized (Singleton.class) &#123; if(instance==null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 这是一种懒汉的单例模式，使用时才创建对象，而且为了避免初始化操作的指令重排序，给instance加上了volatile。 面试官： 来给我们说说几种单例模式的写法吧，还有上面这种用法，你再详细说说呢？好吧，这又是一个话题了，volatile的问题终于问完了。。。看看你掌握了没 作者：卡巴拉的树链接：https://juejin.im/post/5a2b53b7f265da432a7b821c来源：掘金","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"black magic","slug":"black-magic","permalink":"http://yoursite.com/tags/black-magic/"},{"name":"fucking trick","slug":"fucking-trick","permalink":"http://yoursite.com/tags/fucking-trick/"},{"name":"jdk","slug":"jdk","permalink":"http://yoursite.com/tags/jdk/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-01-20T07:15:13.969Z","updated":"2018-01-21T11:52:20.373Z","comments":true,"path":"2018/01/20/hello-world/","link":"","permalink":"http://yoursite.com/2018/01/20/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"知乎爬虫","slug":"zhihu-crawler","date":"2018-01-20T07:08:32.000Z","updated":"2018-01-21T11:52:28.502Z","comments":true,"path":"2018/01/20/zhihu-crawler/","link":"","permalink":"http://yoursite.com/2018/01/20/zhihu-crawler/","excerpt":"zhihu-crawler是一个基于Java的爬虫实战项目，主要功能是抓取知乎用户的基本资料，如果觉得不错，请给个star。","text":"zhihu-crawler是一个基于Java的爬虫实战项目，主要功能是抓取知乎用户的基本资料，如果觉得不错，请给个star。 爬取结果 下图为爬取117w知乎用户数据的简单统计 详细统计见 https://www.vwycm.cn/zhihu/charts 工程导入(maven) git clone https://github.com/wycm/zhihu-crawler 克隆项目到本地 eclipse导入步骤(eclipse_kepler版本，自带maven)，File-&gt;Import-&gt;Maven-&gt;Existing Maven Projects-&gt;选择刚刚clone的zhihu-crawler目录-&gt;导入成功 idea导入步骤,File-&gt;Open-&gt;选择刚刚clone的zhihu-crawler目录-&gt;导入成功 工程导入(不使用maven) eclipse或myeclipse都可以 git clone https://github.com/wycm/zhihu-crawler 克隆项目到本地 创建一个名字为zhihu-new-crawler（这个随便命名）的普通工程 拷贝刚刚clone的zhihu-crawler/src/main/java/com目录到zhihu-new-crawler/src目录下 右键工程-&gt;Build Path-&gt;Add External Archives…-&gt;导入zhihu-crawler/lib下的所有jar包 将zhihu-crawler/src/main/resources目录下的config.properties和log4j.properties拷贝至src目录下 Quick StartRun with Main.java 使用到的API 地址(url)：12345678910* 请求类型：GET* **请求参数**| 参数名 |类型 | 必填 | 值 | 说明|| :------------ | :------------ | :------------ | :----- | :------------ || include | String | 是| ```data[*]answer_count,articles_count``` |需要返回的字段（这个值可以改根据需要增加一些字段，见如下示例url） || offset | int | 是| 0 | 偏移量（通过调整这个值可以获取到一个用户的```所有关注用户```资料） || limit | int | 是| 20 | 返回用户数（最大20，超过20无效） |* url示例：```https://www.zhihu.com/api/v4/members/wo-yan-chen-mo/followees?include=data[*].educations,employments,answer_count,business,locations,articles_count,follower_count,gender,following_count,question_count,voteup_count,thanked_count,is_followed,is_following,badge[?(type=best_answerer)].topics&amp;offset=0&amp;limit=20 响应：json数据，会有关注用户资料 注意：这个请求采用了oauth验证，需要在http header加上authorization:oauth c3cef7c66a1843f8b3a9e6a1e3160e20,这个值是存放在js文件中，详细获取方式见代码。 使用到的三方库 HttpClient4.5-网络请求 Jsoup-html标签解析 JsonPath-json数据解析 Features 大量使用http代理，突破同一个客户端访问量限制。 支持持久化(mysql),相关配置见config.properties。 多线程、爬取速度快。 持久化配置 如果要持久化数据到mysql，先手动创建数据库，然后修改配置文件config.properties的如下属性。 db.enable = true db.host =ip地址 db.username = 用户名 db.password = 密码 db.name = 数据库名 流程图 更新2016.12.26 移除未使用的包，修复ConcurrentModificationException和NoSuchElementException异常问题。 增加游客（免登录）模式抓取。 增加代理抓取模块。 2017.01.10 不再采用登录抓取，并移除登录抓取相关模块，模拟登录的主要逻辑代码见ModelLogin.java。 优化项目结构，加快爬取速度。采用ListPageThreadPool和DetailPageThreadPool两个线程池。ListPageThreadPool负责下载”关注用户“列表页，解析出关注用户，将关注用户的url去重，然后放到DetailPageThreadPool线程池。DetailPageThreadPool负责下载用户详情页面，解析出用户基本信息并入库，获取该用户的”关注用户”的列表页url并放到ListPageThreadPool。 2017.01.17 增加代理序列化。 调整项目结构，大幅度提高爬取速度。不再使用ListPageThreadPool和DetailPageThreadPool的方式。直接下载关注列表页，可以直接获取到用户详细资料。 2017.03.30 知乎api变更，关注列表页不能获取到关注人数，导致线程池任务不能持续下去。抓取模式切换成原来ListPageThreadPool和DetailPageThreadPool的方式。 2017.05.26 修复代理返回错误数据，导致java.lang.reflect.UndeclaredThrowableException异常。 2017.11.05 知乎authorization文件更新，修改authorization获取方式。TODO 优化爬取速度 最后 想要爬取其它数据，如问题、答案等，完全可以在此基础上自己定制。 有问题的请提issue。 欢迎贡献代码。 爬虫交流群：633925314，欢迎交流。","categories":[{"name":"github","slug":"github","permalink":"http://yoursite.com/categories/github/"}],"tags":[{"name":"black magic","slug":"black-magic","permalink":"http://yoursite.com/tags/black-magic/"},{"name":"fucking trick","slug":"fucking-trick","permalink":"http://yoursite.com/tags/fucking-trick/"}]},{"title":"基础框架-Maven模块化","slug":"frame-modular","date":"2018-01-20T07:08:32.000Z","updated":"2018-01-21T11:52:11.795Z","comments":true,"path":"2018/01/20/frame-modular/","link":"","permalink":"http://yoursite.com/2018/01/20/frame-modular/","excerpt":"这个是maven分模块的工程。","text":"这个是maven分模块的工程。 IDE设置 git clone 代码 mvn install 在工作目录中使用mvn eclipse:eclipse[Eclipse]或mvn idea:idea[Intellij IDEA]初始化工程 在IDE中导入已有工程 打包与运行 打包jar命令：mvn package -P dev[开发环境配置]，mvn package -P online[生产环境配置]其中，开发环境dev的配置位于src/main/resources/dev中，生产环境online的配置位于src/main/resources/online中默认为dev开发环境的配置 运行其中datadriver-web中是war包，该包中包含有其他模块的jar在lib目录中","categories":[{"name":"Datadriver","slug":"Datadriver","permalink":"http://yoursite.com/categories/Datadriver/"}],"tags":[{"name":"black magic","slug":"black-magic","permalink":"http://yoursite.com/tags/black-magic/"},{"name":"fucking trick","slug":"fucking-trick","permalink":"http://yoursite.com/tags/fucking-trick/"}]}]}