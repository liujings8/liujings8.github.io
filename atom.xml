<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>phantomliu&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liujings8.github.io/"/>
  <updated>2019-05-05T17:45:26.813Z</updated>
  <id>https://liujings8.github.io/</id>
  
  <author>
    <name>phantomliu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://liujings8.github.io/2019/05/05/hello-world/"/>
    <id>https://liujings8.github.io/2019/05/05/hello-world/</id>
    <published>2019-05-05T15:39:52.734Z</published>
    <updated>2019-05-05T17:45:26.813Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>乐观锁与悲观锁的实际应用</title>
    <link href="https://liujings8.github.io/2018/02/11/optimistic-pessimistic-lock/"/>
    <id>https://liujings8.github.io/2018/02/11/optimistic-pessimistic-lock/</id>
    <published>2018-02-11T09:24:26.000Z</published>
    <updated>2019-05-05T17:45:46.351Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>oralce查询某个字段不为空或者为空的SQL语句</title>
    <link href="https://liujings8.github.io/2018/02/09/oracle-null/"/>
    <id>https://liujings8.github.io/2018/02/09/oracle-null/</id>
    <published>2018-02-09T02:24:26.000Z</published>
    <updated>2019-05-05T17:45:52.840Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="oracle" scheme="https://liujings8.github.io/categories/oracle/"/>
    
    
      <category term="oracle" scheme="https://liujings8.github.io/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>LinkedHashMap 底层分析</title>
    <link href="https://liujings8.github.io/2018/02/08/linkedHashMap-analysis/"/>
    <id>https://liujings8.github.io/2018/02/08/linkedHashMap-analysis/</id>
    <published>2018-02-08T01:40:50.000Z</published>
    <updated>2019-05-05T17:45:39.878Z</updated>
    
    <content type="html"><![CDATA[<p>  众所周知HashMap是一个无顺序的Map,因为每次根据key的hashcode映射到Entry<br>数组上，所以遍历出来的顺序并不是写入的顺序。</p><p>因此JDK退出一个机遇HashMap但具有顺序的LinkedHashMap来解决有排序需求的场景。<br>它的底层是继承于HashMap实现的，有一个双向链表所构成。<br>LinkedHashMap的排序方式有两种：<br>1.根据写入的顺序排序。<br>2.根据访问的顺序排序。<br>其中根据访问顺讯排序时，每次get都会将访问的值移动到链表末尾，这样操作就能<br>得到一个按照访问顺序的链表。<br>数据结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test()&#123;</span><br><span class="line">    Map&lt;String,Integer&gt; map = new LinkedHashMap&lt;&gt;();</span><br><span class="line">    map.put(&quot;1&quot;,1);</span><br><span class="line">    map.put(&quot;2&quot;,2);</span><br><span class="line">    map.put(&quot;3&quot;,3);</span><br><span class="line">    map.put(&quot;4&quot;,4);</span><br><span class="line">    map.put(&quot;5&quot;,5);</span><br><span class="line">    System.out.println(map.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调试可以看到map的组成。<br>—capture pic</p><p>打开源码可以看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The head of the doubly linked list.</span><br><span class="line"> */</span><br><span class="line">private transient Entry&lt;K,V&gt; header;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt;</span><br><span class="line"> * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order.</span><br><span class="line"> *</span><br><span class="line"> * @serial</span><br><span class="line"> */</span><br><span class="line">private final boolean accessOrder;</span><br><span class="line"></span><br><span class="line">private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    // These fields comprise the doubly linked list used for iteration.</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line"></span><br><span class="line">    Entry(int hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中Entry继承于HashMap的Entry，并新增上下节点的指针，也就形成了双向链表。<br>还有一个header的成员变量，是这个双向链表的头节点。<br>上面demo总计程一张图如下：<br>—-capture pic</p><p>第一个类似于HshMap的结构。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  众所周知HashMap是一个无顺序的Map,因为每次根据key的hashcode映射到Entry&lt;br&gt;数组上，所以遍历出来的顺序并不是写入的顺序。&lt;/p&gt;
&lt;p&gt;因此JDK退出一个机遇HashMap但具有顺序的LinkedHashMap来解决有排序需求的场景。&lt;br&gt;它的底层是继承于HashMap实现的，有一个双向链表所构成。&lt;br&gt;LinkedHashMap的排序方式有两种：&lt;br&gt;1.根据写入的顺序排序。&lt;br&gt;2.根据访问的顺序排序。&lt;br&gt;其中根据访问顺讯排序时，每次get都会将访问的值移动到链表末尾，这样操作就能&lt;br&gt;得到一个按照访问顺序的链表。&lt;br&gt;数据结构&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@Test&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public void test()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Map&amp;lt;String,Integer&amp;gt; map = new LinkedHashMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    map.put(&amp;quot;1&amp;quot;,1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    map.put(&amp;quot;2&amp;quot;,2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    map.put(&amp;quot;3&amp;quot;,3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    map.put(&amp;quot;4&amp;quot;,4);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    map.put(&amp;quot;5&amp;quot;,5);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(map.toString());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;调试可以看到map的组成。&lt;br&gt;—capture pic&lt;/p&gt;
&lt;p&gt;打开源码可以看到：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * The head of the doubly linked list.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private transient Entry&amp;lt;K,V&amp;gt; header;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * The iteration ordering method for this linked hash map: &amp;lt;tt&amp;gt;true&amp;lt;/tt&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * for access-order, &amp;lt;tt&amp;gt;false&amp;lt;/tt&amp;gt; for insertion-order.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @serial&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private final boolean accessOrder;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private static class Entry&amp;lt;K,V&amp;gt; extends HashMap.Entry&amp;lt;K,V&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // These fields comprise the doubly linked list used for iteration.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Entry&amp;lt;K,V&amp;gt; before, after;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Entry(int hash, K key, V value, HashMap.Entry&amp;lt;K,V&amp;gt; next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        super(hash, key, value, next);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中Entry继承于HashMap的Entry，并新增上下节点的指针，也就形成了双向链表。&lt;br&gt;还有一个header的成员变量，是这个双向链表的头节点。&lt;br&gt;上面demo总计程一张图如下：&lt;br&gt;—-capture pic&lt;/p&gt;
&lt;p&gt;第一个类似于HshMap的结构。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://liujings8.github.io/categories/java/"/>
    
    
      <category term="Java" scheme="https://liujings8.github.io/tags/Java/"/>
    
      <category term="HashMap" scheme="https://liujings8.github.io/tags/HashMap/"/>
    
      <category term="LinkedHash" scheme="https://liujings8.github.io/tags/LinkedHash/"/>
    
      <category term="jdk" scheme="https://liujings8.github.io/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>常用软件激活教程</title>
    <link href="https://liujings8.github.io/2018/02/07/software-activation/"/>
    <id>https://liujings8.github.io/2018/02/07/software-activation/</id>
    <published>2018-02-07T06:15:00.000Z</published>
    <updated>2019-05-05T17:46:06.393Z</updated>
    
    <content type="html"><![CDATA[<h4 id="IntelliJ-IDEA-激活"><a href="#IntelliJ-IDEA-激活" class="headerlink" title="IntelliJ IDEA 激活"></a>IntelliJ IDEA 激活</h4><ul><li><h5 id="REFER-TO"><a href="#REFER-TO" class="headerlink" title="REFER TO"></a>REFER TO</h5><a href="http://blog.lanyus.com/" target="_blank" rel="noopener">http://blog.lanyus.com/</a></li><li><h5 id="TIME"><a href="#TIME" class="headerlink" title="TIME"></a>TIME</h5>2018-02-08</li><li><h5 id="VERSION"><a href="#VERSION" class="headerlink" title="VERSION"></a>VERSION</h5>IntelliJ IDEA 2017.3.4(Ultimate Edition)<a id="more"></a></li></ul><h4 id="IntelliJ-IDEA-Mybatis-Plugin-激活"><a href="#IntelliJ-IDEA-Mybatis-Plugin-激活" class="headerlink" title="IntelliJ IDEA Mybatis Plugin 激活"></a>IntelliJ IDEA Mybatis Plugin 激活</h4><ul><li><h5 id="REFER-TO-1"><a href="#REFER-TO-1" class="headerlink" title="REFER TO"></a>REFER TO</h5><a href="http://shawnho.me/2017/12/20/ideaagent/" target="_blank" rel="noopener">http://shawnho.me/2017/12/20/ideaagent/</a><br><a href="https://github.com/mrshawnho/ideaagent" target="_blank" rel="noopener">https://github.com/mrshawnho/ideaagent</a></li><li><h5 id="TIME-1"><a href="#TIME-1" class="headerlink" title="TIME"></a>TIME</h5>2018-02-07</li><li><h5 id="VERSION-1"><a href="#VERSION-1" class="headerlink" title="VERSION"></a>VERSION</h5>Mybatis Plugin 3.42<br>IntelliJ IDEA 2017.3.4(Ultimate Edition)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;IntelliJ-IDEA-激活&quot;&gt;&lt;a href=&quot;#IntelliJ-IDEA-激活&quot; class=&quot;headerlink&quot; title=&quot;IntelliJ IDEA 激活&quot;&gt;&lt;/a&gt;IntelliJ IDEA 激活&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;h5 id=&quot;REFER-TO&quot;&gt;&lt;a href=&quot;#REFER-TO&quot; class=&quot;headerlink&quot; title=&quot;REFER TO&quot;&gt;&lt;/a&gt;REFER TO&lt;/h5&gt;&lt;a href=&quot;http://blog.lanyus.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.lanyus.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;h5 id=&quot;TIME&quot;&gt;&lt;a href=&quot;#TIME&quot; class=&quot;headerlink&quot; title=&quot;TIME&quot;&gt;&lt;/a&gt;TIME&lt;/h5&gt;2018-02-08&lt;/li&gt;
&lt;li&gt;&lt;h5 id=&quot;VERSION&quot;&gt;&lt;a href=&quot;#VERSION&quot; class=&quot;headerlink&quot; title=&quot;VERSION&quot;&gt;&lt;/a&gt;VERSION&lt;/h5&gt;IntelliJ IDEA 2017.3.4(Ultimate Edition)
    
    </summary>
    
      <category term="software" scheme="https://liujings8.github.io/categories/software/"/>
    
    
      <category term="software" scheme="https://liujings8.github.io/tags/software/"/>
    
      <category term="activation" scheme="https://liujings8.github.io/tags/activation/"/>
    
  </entry>
  
  <entry>
    <title>常用工具集</title>
    <link href="https://liujings8.github.io/2018/02/06/toolkit/"/>
    <id>https://liujings8.github.io/2018/02/06/toolkit/</id>
    <published>2018-02-06T06:15:00.000Z</published>
    <updated>2019-05-05T17:46:12.091Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="software" scheme="https://liujings8.github.io/categories/software/"/>
    
    
      <category term="launchy" scheme="https://liujings8.github.io/tags/launchy/"/>
    
      <category term="weex" scheme="https://liujings8.github.io/tags/weex/"/>
    
      <category term="everything" scheme="https://liujings8.github.io/tags/everything/"/>
    
      <category term="listary" scheme="https://liujings8.github.io/tags/listary/"/>
    
  </entry>
  
  <entry>
    <title>oralce数据库时间操作</title>
    <link href="https://liujings8.github.io/2018/02/06/oralce-date-operation/"/>
    <id>https://liujings8.github.io/2018/02/06/oralce-date-operation/</id>
    <published>2018-02-06T06:15:00.000Z</published>
    <updated>2019-05-05T17:45:58.177Z</updated>
    
    <content type="html"><![CDATA[<h4 id="查看数据库版本"><a href="#查看数据库版本" class="headerlink" title="查看数据库版本"></a>查看数据库版本</h4><ul><li><h5 id="v-version"><a href="#v-version" class="headerlink" title="v$version"></a>v$version</h5><p>SQL&gt; select * from v$version;<br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/20180129093548.png" alt title>                </div>                <div class="image-caption"></div>            </figure><a id="more"></a></li><li><h5 id="product-component-version"><a href="#product-component-version" class="headerlink" title="product_component_version"></a>product_component_version</h5><p>SQL&gt; select * from product_component_version;<br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/20180129094432.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ul><h4 id="获取年月日时分秒"><a href="#获取年月日时分秒" class="headerlink" title="获取年月日时分秒"></a>获取年月日时分秒</h4><ul><li><h5 id="获取年"><a href="#获取年" class="headerlink" title="获取年"></a>获取年</h5><p>select to_char(sysdate,’yyyy’) from dual; – 2018<br>select to_char(sysdate,’YYYY’) from dual; – 2018</p></li><li><h5 id="获取月"><a href="#获取月" class="headerlink" title="获取月"></a>获取月</h5><p>select to_char(sysdate,’mm’) from dual; – 1<br>select to_char(sysdate,’MM’) from dual; – 1</p></li><li><h5 id="获取日"><a href="#获取日" class="headerlink" title="获取日"></a>获取日</h5><p>select to_char(sysdate,’dd’) from dual; – 29<br>select to_char(sysdate,’DD’) from dual; – 29</p></li><li><h5 id="获取时"><a href="#获取时" class="headerlink" title="获取时"></a>获取时</h5><p>select to_char(sysdate,’hh’) from dual; – 04<br>select to_char(sysdate,’HH’) from dual; – 04<br>select to_char(sysdate,’hh24’) from dual; – 16<br>select to_char(sysdate,’HH24’) from dual; – 16</p></li><li><h5 id="获取分钟"><a href="#获取分钟" class="headerlink" title="获取分钟"></a>获取分钟</h5><p>select to_char(sysdate,’mi’) from dual; – 03<br>select to_char(sysdate,’MI’) from dual; – 03</p></li><li><h5 id="获取秒"><a href="#获取秒" class="headerlink" title="获取秒"></a>获取秒</h5><p>select to_char(sysdate,’ss’) from dual; – 40<br>select to_char(sysdate,’SS’) from dual; – 40</p></li><li><h5 id="获取年月日时分秒-1"><a href="#获取年月日时分秒-1" class="headerlink" title="获取年月日时分秒"></a>获取年月日时分秒</h5><p>select to_char(sysdate,’yyyy-mm-dd hh:mi:ss’) from dual; – 2018-01-29 16:06:15<br>select to_char(sysdate,’yyyy-mm-dd hh24:mi:ss’) from dual; – 2018-01-29 16:06:15</p><p><em>说明:</em><br>(1) 从上面的测试SQL可以看出yyyy, mm, dd, hh, mi, ss的大小写对于从oracle中获取年月日时分秒没有影响<br>(2) 对于获取小时分12小时和24小时的情况，如果你想显示下午的时间，你可以采用hh24, 这样就会显示类似于15:30而不是03:30</p></li></ul><h4 id="获取一周前，一个月前，一年前的日期"><a href="#获取一周前，一个月前，一年前的日期" class="headerlink" title="获取一周前，一个月前，一年前的日期"></a>获取一周前，一个月前，一年前的日期</h4><ul><li><h5 id="获取当前时间一周前的时间"><a href="#获取当前时间一周前的时间" class="headerlink" title="获取当前时间一周前的时间"></a>获取当前时间一周前的时间</h5><p>SQL&gt; select sysdate - interval ‘7’ day from dual;</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/20180129101923.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>类似的(其他)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 当前时间减去7分钟的时间</span><br><span class="line">select sysdate, sysdate - interval &apos;7&apos; minute from dual;</span><br><span class="line">-- 当前时间减去7小时的时间</span><br><span class="line">select sysdate, sysdate - interval &apos;7&apos; hour from dual;</span><br><span class="line">-- 当前时间减去7天的时间</span><br><span class="line">select sysdate, sysdate - interval &apos;7&apos; day from dual;</span><br><span class="line">-- 当前时间减去7月的时间</span><br><span class="line">select sysdate, sysdate - interval &apos;7&apos; month from dual;</span><br><span class="line">-- 当前时间减去7年的时间</span><br><span class="line">select sysdate, sysdate - interval &apos;7&apos; year from dual;</span><br><span class="line">-- 时间间隔乘以一个数字(16小时)</span><br><span class="line">select sysdate, sysdate - 8 *interval &apos;2&apos; hour from dual;</span><br></pre></td></tr></table></figure><p><img src="/images/20180129102848.png" alt></p></li></ul><h4 id="根据当前时间获取最近5年，最近6个月，最近30天的时间"><a href="#根据当前时间获取最近5年，最近6个月，最近30天的时间" class="headerlink" title="根据当前时间获取最近5年，最近6个月，最近30天的时间"></a>根据当前时间获取最近5年，最近6个月，最近30天的时间</h4><ul><li><h5 id="根据当前时间获取最近5年时间：-yyyy"><a href="#根据当前时间获取最近5年时间：-yyyy" class="headerlink" title="根据当前时间获取最近5年时间：(yyyy)"></a>根据当前时间获取最近5年时间：(yyyy)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select level as &quot;level&quot;,to_char(sysdate,&apos;yyyy&apos;) - level + 1 as &quot;xAxisValue&quot; from dual</span><br><span class="line">connect by level &lt;= 5</span><br><span class="line">order by to_char(sysdate,&apos;yyyy&apos;) - level + 1 asc</span><br></pre></td></tr></table></figure><p><img src="/images/20180129103913.png" alt></p></li><li><h5 id="根据当前时间获取最近6个月的时间：-yyyy-mm"><a href="#根据当前时间获取最近6个月的时间：-yyyy-mm" class="headerlink" title="根据当前时间获取最近6个月的时间：(yyyy-mm)"></a>根据当前时间获取最近6个月的时间：(yyyy-mm)</h5></li></ul><ol><li><p>先拆解一下SQL语句</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select trunc(sysdate, <span class="string">'mm'</span>)+1 from dual;-- 2018/1/2</span><br><span class="line">select to_char(trunc(sysdate, <span class="string">'mm'</span>)+1, <span class="string">'yyyy-mm'</span>) from dual;-- 2018-01</span><br><span class="line">select to_date(to_char(trunc(sysdate, <span class="string">'mm'</span>)+1, <span class="string">'yyyy-mm'</span>),<span class="string">'yyyy-mm'</span>) from dual;-- 2018/1/1</span><br><span class="line">select add_months(to_date(to_char(trunc(sysdate, <span class="string">'mm'</span>)+1, <span class="string">'yyyy-mm'</span>),<span class="string">'yyyy-mm'</span>),-1) from dual;-- 2017/12/1</span><br><span class="line">select to_char(add_months(to_date(to_char(trunc(sysdate, <span class="string">'mm'</span>)+1, <span class="string">'yyyy-mm'</span>),<span class="string">'yyyy-mm'</span>),-1),<span class="string">'yyyy-mm'</span>) from dual;-- 2017-12</span><br></pre></td></tr></table></figure></li><li><p>执行SQL语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select to_char(add_months(to_date(to_char(trunc(sysdate, &apos;mm&apos;)+1, &apos;yyyy-mm&apos;),&apos;yyyy-mm&apos;),-(rownum - 1)),&apos;yyyy-mm&apos;) as xAxisValue from dual</span><br><span class="line">connect by rownum &lt;=6</span><br><span class="line">order by xAxisValue asc</span><br></pre></td></tr></table></figure></li><li><p>结果:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/20180129111527.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ol><ul><li><h5 id="根据当前时间获取最近30天时间：-yyyy-mm-dd"><a href="#根据当前时间获取最近30天时间：-yyyy-mm-dd" class="headerlink" title="根据当前时间获取最近30天时间：(yyyy-mm-dd)"></a>根据当前时间获取最近30天时间：(yyyy-mm-dd)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select to_char(day,&apos;yyyy-mm-dd&apos;) as &quot;xAxisValue&quot; from</span><br><span class="line">(select to_date(to_char(trunc(sysdate,&apos;dd&apos;),&apos;yyyy-mm-dd&apos;),&apos;yyyy-mm-dd&apos;) - rownnum + 1 as day from dual</span><br><span class="line">connect by rownum &lt;= 30) order by day asc</span><br></pre></td></tr></table></figure><p>也可以根据输入启止时间来获取时间段内的天：如下为获取2017-06-10到2017-07-10时间段内的天(yyyy-mm-dd)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select to_char(day,&apos;yyyy-mm-dd&apos;) from</span><br><span class="line">(select to_date(to_char(trunc(to_date(&apos;2017-07-10&apos;,&apos;yyyy-mm-dd&apos;),&apos;dd&apos;),&apos;yyyy-mm-dd&apos;),&apos;yyyy-mm-dd&apos;) - rownum + 1 as day from dual</span><br><span class="line">connect by rownum &lt;= to_date(&apos;2017-07-10&apos;,&apos;yyyy-mm-dd&apos;) - to_date(&apos;2017-06-10&apos;,&apos;yyyy-mm-dd&apos;) + 1) order by day asc</span><br></pre></td></tr></table></figure></li></ul><h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><p>如何查看Oracle数据库版本: <a href="https://www.2cto.com/database/201209/155673.html" target="_blank" rel="noopener">https://www.2cto.com/database/201209/155673.html</a><br>oracle中获取年月日时分秒: <a href="http://blog.csdn.net/u012934325/article/details/52778136" target="_blank" rel="noopener">http://blog.csdn.net/u012934325/article/details/52778136</a><br>Oracle获取一周前，一个月前，一年前的日期:<br><a href="http://blog.csdn.net/siqilou/article/details/40887919" target="_blank" rel="noopener">http://blog.csdn.net/siqilou/article/details/40887919</a><br>Oracle根据当前时间获取最近5年，最近6个月，最近30天的时间：<a href="http://blog.csdn.net/maple_fix/article/details/74926226" target="_blank" rel="noopener">http://blog.csdn.net/maple_fix/article/details/74926226</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;查看数据库版本&quot;&gt;&lt;a href=&quot;#查看数据库版本&quot; class=&quot;headerlink&quot; title=&quot;查看数据库版本&quot;&gt;&lt;/a&gt;查看数据库版本&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;h5 id=&quot;v-version&quot;&gt;&lt;a href=&quot;#v-version&quot; class=&quot;headerlink&quot; title=&quot;v$version&quot;&gt;&lt;/a&gt;v$version&lt;/h5&gt;&lt;p&gt;SQL&amp;gt; select * from v$version;&lt;br&gt;&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;/images/20180129093548.png&quot; alt title&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
      <category term="software" scheme="https://liujings8.github.io/categories/software/"/>
    
    
      <category term="date" scheme="https://liujings8.github.io/tags/date/"/>
    
      <category term="oracle" scheme="https://liujings8.github.io/tags/oracle/"/>
    
  </entry>
  
  <entry>
    <title>面试官最爱的volatile关键字</title>
    <link href="https://liujings8.github.io/2018/01/22/interviewer-favorite-volatile-keyword/"/>
    <id>https://liujings8.github.io/2018/01/22/interviewer-favorite-volatile-keyword/</id>
    <published>2018-01-22T15:08:32.000Z</published>
    <updated>2019-05-05T17:45:32.926Z</updated>
    
    <content type="html"><![CDATA[<p>在Java相关的岗位面试中，很多面试官都喜欢考察面试者对Java并发的了解程度，而以<strong>volatile</strong>关键字作为一个小的切入点，往往可以一问到底，把Java内存模型（JMM），Java并发编程的一些特性都牵扯出来，深入地话还可以考察JVM底层实现以及操作系统的相关知识。<br><a id="more"></a></p><p>下面我们以一次假想的面试过程，来深入了解下volitile关键字吧</p><h2 id="面试官-Java并发这块了解的怎么样？说说你对volatile关键字的理解"><a href="#面试官-Java并发这块了解的怎么样？说说你对volatile关键字的理解" class="headerlink" title="面试官: Java并发这块了解的怎么样？说说你对volatile关键字的理解"></a>面试官: Java并发这块了解的怎么样？说说你对volatile关键字的理解</h2><p>就我理解的而言，被volatile修饰的共享变量，就具有了以下两点特性：</p><p>1 . 保证了不同线程对该变量操作的内存可见性;</p><p>2 . 禁止指令重排序</p><h2 id="面试官-能不能详细说下什么是内存可见性，什么又是重排序呢？"><a href="#面试官-能不能详细说下什么是内存可见性，什么又是重排序呢？" class="headerlink" title="面试官: 能不能详细说下什么是内存可见性，什么又是重排序呢？"></a>面试官: 能不能详细说下什么是内存可见性，什么又是重排序呢？</h2><p>这个聊起来可就多了，我还是从Java内存模型说起吧。<br>Java虚拟机规范试图定义一种Java内存模型（JMM）,来屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各种平台上都能达到一致的内存访问效果。简单来说，由于CPU执行指令的速度是很快的，但是内存访问的速度就慢了很多，相差的不是一个数量级，所以搞处理器的那群大佬们又在CPU里加了好几层高速缓存。</p><p>在Java内存模型里，对上述的优化又进行了一波抽象。JMM规定所有变量都是存在主存中的，类似于上面提到的普通内存，每个线程又包含自己的工作内存，方便理解就可以看成CPU上的寄存器或者高速缓存。所以线程的操作都是以工作内存为主，它们只能访问自己的工作内存，且工作前后都要把值在同步回主内存。</p><p>这么说得我自己都有些不清楚了，拿张纸画一下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/1603a6fae545a200.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在线程执行时，首先会从主存中read变量值，再load到工作内存中的副本中，然后再传给处理器执行，执行完毕后再给工作内存中的副本赋值，随后工作内存再把值传回给主存，主存中的值才更新。</p><p>使用工作内存和主存，虽然加快的速度，但是也带来了一些问题。比如看下面一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i + 1;</span><br></pre></td></tr></table></figure></p><p>假设i初值为0，当只有一个线程执行它时，结果肯定得到1，当两个线程执行时，会得到结果2吗？这倒不一定了。可能存在这种情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程1： load i from 主存    // i = 0</span><br><span class="line">        i + 1  // i = 1</span><br><span class="line">线程2： load i from主存  // 因为线程1还没将i的值写回主存，所以i还是0</span><br><span class="line">        i +  1 //i = 1</span><br><span class="line">线程1:  save i to 主存</span><br><span class="line">线程2： save i to 主存</span><br></pre></td></tr></table></figure></p><p>如果两个线程按照上面的执行流程，那么i最后的值居然是1了。如果最后的写回生效的慢，你再读取i的值，都可能是0，这就是缓存不一致问题。</p><p>下面就要提到你刚才问到的问题了，JMM主要就是围绕着如何在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的，通过解决这三个问题，可以解除缓存不一致的问题。而volatile跟可见性和有序性都有关。</p><h2 id="面试官：那你具体说说这三个特性呢？"><a href="#面试官：那你具体说说这三个特性呢？" class="headerlink" title="面试官：那你具体说说这三个特性呢？"></a>面试官：那你具体说说这三个特性呢？</h2><p><strong>1 . 原子性(Atomicity)：</strong>Java中，对基本数据类型的读取和赋值操作是原子性操作，所谓原子性操作就是指这些操作是不可中断的，要做一定做完，要么就没有执行。 比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 2;</span><br><span class="line">j = i;</span><br><span class="line">i++;</span><br><span class="line">i = i + 1；</span><br></pre></td></tr></table></figure></p><p>上面4个操作中，i=2是读取操作，必定是原子性操作，j=i你以为是原子性操作，其实吧，分为两步，一是读取i的值，然后再赋值给j,这就是2步操作了，称不上原子操作，i++和i = i + 1其实是等效的，读取i的值，加1，再写回主存，那就是3步操作了。所以上面的举例中，最后的值可能出现多种情况，就是因为满足不了原子性。</p><p>这么说来，只有简单的读取，赋值是原子操作，还只能是用数字赋值，用变量的话还多了一步读取变量值的操作。有个例外是，虚拟机规范中允许对64位数据类型(long和double)，分为2次32为的操作来处理，但是最新JDK实现还是实现了原子操作的。</p><p>JMM只实现了基本的原子性，像上面i++那样的操作，必须借助于synchronized和Lock来保证整块代码的原子性了。线程在释放锁之前，必然会把i的值刷回到主存的。</p><p><strong>2 . 可见性(Visibility)：</strong></p><p>说到可见性，Java就是利用volatile来提供可见性的。<br>当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主存，当其它线程需要读取该变量时，会去内存中读取新值。而普通变量则不能保证这一点。</p><p>其实通过synchronized和Lock也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存，但是synchronized和Lock的开销都更大。</p><p><strong>3 . 有序性（Ordering）</strong></p><p>JMM是允许编译器和处理器对指令重排序的，但是规定了as-if-serial语义，即不管怎么重排序，程序的执行结果不能改变。比如下面的程序段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double pi = 3.14;    //A</span><br><span class="line">double r = 1;        //B</span><br><span class="line">double s= pi * r * r;//C</span><br></pre></td></tr></table></figure></p><p>上面的语句，可以按照A-&gt;B-&gt;C执行，结果为3.14,但是也可以按照B-&gt;A-&gt;C的顺序执行，因为A、B是两句独立的语句，而C则依赖于A、B，所以A、B可以重排序，但是C却不能排到A、B的前面。JMM保证了重排序不会影响到单线程的执行，但是在多线程中却容易出问题。</p><p>比如这样的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">bool flag = false;</span><br><span class="line"></span><br><span class="line">public void write() &#123;</span><br><span class="line">    a = 2;              //1</span><br><span class="line">    flag = true;        //2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void multiply() &#123;</span><br><span class="line">    if (flag) &#123;         //3</span><br><span class="line">        int ret = a * a;//4</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假如有两个线程执行上述代码段，线程1先执行write，随后线程2再执行multiply，最后ret的值一定是4吗？结果不一定：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/1603ac14eb04b21e.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>如图所示，write方法里的1和2做了重排序，线程1先对flag赋值为true，随后执行到线程2，ret直接计算出结果，再到线程1，这时候a才赋值为2,很明显迟了一步。</p><p>这时候可以为flag加上volatile关键字，禁止重排序，可以确保程序的“有序性”，也可以上重量级的synchronized和Lock来保证有序性,它们能保证那一块区域里的代码都是一次性执行完毕的。</p><p>另外，JMM具备一些先天的<strong>有序性</strong>,即不需要通过任何手段就可以保证的有序性，通常称为<strong>happens-before</strong>原则。<code>&lt;&lt;JSR-133：Java Memory Model and Thread Specification&gt;&gt;</code>定义了如下happens-before规则：</p><blockquote><p>1程序顺序规则： 一个线程中的每个操作，happens-before于该线程中的任意后续操作<br>2.监视器锁规则：对一个线程的解锁，happens-before于随后对这个线程的加锁<br>3.volatile变量规则： 对一个volatile域的写，happens-before于后续对这个volatile域的读<br>4.传递性：如果A happens-before B ,且 B happens-before C, 那么 A happens-before C<br>5.start()规则： 如果线程A执行操作ThreadB_start()(启动线程B) ,  那么A线程的ThreadB_start()happens-before 于B中的任意操作<br>6.join()原则： 如果A执行ThreadB.join()并且成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。<br>7.interrupt()原则： 对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生<br>8.finalize()原则：一个对象的初始化完成先行发生于它的finalize()方法的开始</p></blockquote><p>第1条规则程序顺序规则是说在一个线程里，所有的操作都是按顺序的，但是在JMM里其实只要执行结果一样，是允许重排序的，这边的happens-before强调的重点也是单线程执行结果的正确性，但是无法保证多线程也是如此。</p><p>第2条规则监视器规则其实也好理解，就是在加锁之前，确定这个锁之前已经被释放了，才能继续加锁。</p><p>第3条规则，就适用到所讨论的volatile，如果一个线程先去写一个变量，另外一个线程再去读，那么写入操作一定在读操作之前。</p><p>第4条规则，就是happens-before的传递性。</p><p>后面几条就不再一一赘述了。</p><h2 id="面试官：volatile关键字如何满足并发编程的三大特性的？"><a href="#面试官：volatile关键字如何满足并发编程的三大特性的？" class="headerlink" title="面试官：volatile关键字如何满足并发编程的三大特性的？"></a>面试官：volatile关键字如何满足并发编程的三大特性的？</h2><p>那就要重提volatile变量规则： 对一个volatile域的写，happens-before于后续对这个volatile域的读。<br>这条再拎出来说，其实就是如果一个变量声明成是volatile的，那么当我读变量时，总是能读到它的最新值，这里最新值是指不管其它哪个线程对该变量做了写操作，都会立刻被更新到主存里，我也能从主存里读到这个刚写入的值。也就是说volatile关键字可以保证可见性以及有序性。</p><p>继续拿上面的一段代码举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">bool flag = false;</span><br><span class="line"></span><br><span class="line">public void write() &#123;</span><br><span class="line">   a = 2;              //1</span><br><span class="line">   flag = true;        //2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void multiply() &#123;</span><br><span class="line">   if (flag) &#123;         //3</span><br><span class="line">       int ret = a * a;//4</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码不仅仅受到重排序的困扰，即使1、2没有重排序。3也不会那么顺利的执行的。假设还是线程1先执行<code>write</code>操作，线程2再执行<code>multiply</code>操作，由于线程1是在工作内存里把flag赋值为1，不一定立刻写回主存，所以线程2执行时，multiply再从主存读flag值，仍然可能为false，那么括号里的语句将不会执行。</p><p>如果改成下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">volatile bool flag = false;</span><br><span class="line"></span><br><span class="line">public void write() &#123;</span><br><span class="line">   a = 2;              //1</span><br><span class="line">   flag = true;        //2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void multiply() &#123;</span><br><span class="line">   if (flag) &#123;         //3</span><br><span class="line">       int ret = a * a;//4</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么线程1先执行<code>write</code>,线程2再执行<code>multiply</code>。根据happens-before原则，这个过程会满足以下3类规则：</p><p>程序顺序规则：1 happens-before 2; 3 happens-before 4; (volatile限制了指令重排序，所以1 在2 之前执行)<br>volatile规则：2 happens-before 3<br>传递性规则：1 happens-before 4</p><p>从内存语义上来看<br><strong>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存</strong><br><strong>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</strong></p><h2 id="面试官：volatile的两点内存语义能保证可见性和有序性，但是能保证原子性吗？"><a href="#面试官：volatile的两点内存语义能保证可见性和有序性，但是能保证原子性吗？" class="headerlink" title="面试官：volatile的两点内存语义能保证可见性和有序性，但是能保证原子性吗？"></a>面试官：volatile的两点内存语义能保证可见性和有序性，但是能保证原子性吗？</h2><p>首先我回答是不能保证原子性，要是说能保证，也只是对单个volatile变量的读/写具有原子性，但是对于类似volatile++这样的复合操作就无能为力了，比如下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public volatile int inc = 0;</span><br><span class="line"> </span><br><span class="line">    public void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>按道理来说结果是10000，但是运行下很可能是个小于10000的值。有人可能会说volatile不是保证了可见性啊，一个线程对inc的修改，另外一个线程应该立刻看到啊！可是这里的操作inc++是个复合操作啊，包括读取inc的值，对其自增，然后再写回主存。</p><p>假设线程A，读取了inc的值为10，这时候被阻塞了，因为没有对变量进行修改，触发不了volatile规则。</p><p>线程B此时也读读inc的值，主存里inc的值依旧为10，做自增，然后立刻就被写回主存了，为11。</p><p>此时又轮到线程A执行，由于工作内存里保存的是10，所以继续做自增，再写回主存，11又被写了一遍。所以虽然两个线程执行了两次increase()，结果却只加了一次。</p><p>有人说，<strong>volatile不是会使缓存行无效的吗？</strong>但是这里线程A读取到线程B也进行操作之前，并没有修改inc值，所以线程B读取的时候，还是读的10。</p><p>又有人说，线程B将11写回主存，<strong>不会把线程A的缓存行设为无效吗？</strong>但是线程A的读取操作已经做过了啊，只有在做读取操作时，发现自己缓存行无效，才会去读主存的值，所以这里线程A只能继续做自增了。</p><p>综上所述，在这种复合操作的情景下，原子性的功能是维持不了了。但是volatile在上面那种设置flag值的例子里，由于对flag的读/写操作都是单步的，所以还是能保证原子性的。</p><p>要想保证原子性，只能借助于synchronized,Lock以及并发包下的atomic的原子操作类了，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。</p><h2 id="面试官：说的还可以，那你知道volatile底层的实现机制？"><a href="#面试官：说的还可以，那你知道volatile底层的实现机制？" class="headerlink" title="面试官：说的还可以，那你知道volatile底层的实现机制？"></a>面试官：说的还可以，那你知道volatile底层的实现机制？</h2><p>如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。</p><p>lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能：</p><p>1 . 重排序时不能把后面的指令重排序到内存屏障之前的位置<br>2 . 使得本CPU的Cache写入内存<br>3 . 写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见。</p><h2 id="面试官：-你在哪里会使用到volatile，举两个例子呢？"><a href="#面试官：-你在哪里会使用到volatile，举两个例子呢？" class="headerlink" title="面试官： 你在哪里会使用到volatile，举两个例子呢？"></a>面试官： 你在哪里会使用到volatile，举两个例子呢？</h2><p>1.状态量标记，就如上面对flag的标记，我重新提一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">volatile bool flag = false;</span><br><span class="line"></span><br><span class="line">public void write() &#123;</span><br><span class="line">    a = 2;              //1</span><br><span class="line">    flag = true;        //2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void multiply() &#123;</span><br><span class="line">    if (flag) &#123;         //3</span><br><span class="line">        int ret = a * a;//4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种对变量的读写操作，标记为volatile可以保证修改对线程立刻可见。比synchronized,Lock有一定的效率提升。</p><p>2.单例模式的实现，典型的双重检查锁定（DCL）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">    private volatile static Singleton instance = null;</span><br><span class="line"> </span><br><span class="line">    private Singleton() &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if(instance==null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if(instance==null)</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一种懒汉的单例模式，使用时才创建对象，而且为了避免初始化操作的指令重排序，给instance加上了volatile。</p><h2 id="面试官：-来给我们说说几种单例模式的写法吧，还有上面这种用法，你再详细说说呢？"><a href="#面试官：-来给我们说说几种单例模式的写法吧，还有上面这种用法，你再详细说说呢？" class="headerlink" title="面试官： 来给我们说说几种单例模式的写法吧，还有上面这种用法，你再详细说说呢？"></a>面试官： 来给我们说说几种单例模式的写法吧，还有上面这种用法，你再详细说说呢？</h2><p>好吧，这又是一个话题了，volatile的问题终于问完了。。。看看你掌握了没</p><p>作者：卡巴拉的树<br>链接：<a href="https://juejin.im/post/5a2b53b7f265da432a7b821c" target="_blank" rel="noopener">https://juejin.im/post/5a2b53b7f265da432a7b821c</a><br>来源：掘金</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java相关的岗位面试中，很多面试官都喜欢考察面试者对Java并发的了解程度，而以&lt;strong&gt;volatile&lt;/strong&gt;关键字作为一个小的切入点，往往可以一问到底，把Java内存模型（JMM），Java并发编程的一些特性都牵扯出来，深入地话还可以考察JVM底层实现以及操作系统的相关知识。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="https://liujings8.github.io/categories/java/"/>
    
    
      <category term="black magic" scheme="https://liujings8.github.io/tags/black-magic/"/>
    
      <category term="fucking trick" scheme="https://liujings8.github.io/tags/fucking-trick/"/>
    
      <category term="jdk" scheme="https://liujings8.github.io/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>基础框架-Maven模块化</title>
    <link href="https://liujings8.github.io/2018/01/20/frame-modular/"/>
    <id>https://liujings8.github.io/2018/01/20/frame-modular/</id>
    <published>2018-01-20T07:08:32.000Z</published>
    <updated>2019-05-05T17:45:01.809Z</updated>
    
    <content type="html"><![CDATA[<p>这个是maven分模块的工程。<br><a id="more"></a></p><h2 id="IDE设置"><a href="#IDE设置" class="headerlink" title="IDE设置"></a>IDE设置</h2><ol><li>git clone 代码</li><li><code>mvn install</code></li><li>在工作目录中使用<code>mvn eclipse:eclipse</code>[Eclipse]或<code>mvn idea:idea</code>[Intellij IDEA]初始化工程</li><li>在IDE中导入已有工程</li></ol><h2 id="打包与运行"><a href="#打包与运行" class="headerlink" title="打包与运行"></a>打包与运行</h2><ul><li><p>打包jar<br>命令：<code>mvn package -P dev</code>[开发环境配置]，<code>mvn package -P online</code>[生产环境配置]<br><br>其中，开发环境dev的配置位于<code>src/main/resources/dev</code>中，生产环境online的配置位于<code>src/main/resources/online</code>中<br><br>默认为dev开发环境的配置</p></li><li><p>运行<br>其中<code>datadriver-web</code>中是war包，该包中包含有其他模块的jar在lib目录中</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个是maven分模块的工程。&lt;br&gt;
    
    </summary>
    
      <category term="datadriver" scheme="https://liujings8.github.io/categories/datadriver/"/>
    
    
      <category term="black magic" scheme="https://liujings8.github.io/tags/black-magic/"/>
    
      <category term="fucking trick" scheme="https://liujings8.github.io/tags/fucking-trick/"/>
    
      <category term="maven" scheme="https://liujings8.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>知乎爬虫</title>
    <link href="https://liujings8.github.io/2018/01/20/zhihu-crawler/"/>
    <id>https://liujings8.github.io/2018/01/20/zhihu-crawler/</id>
    <published>2018-01-20T07:08:32.000Z</published>
    <updated>2019-05-05T17:46:18.339Z</updated>
    
    <content type="html"><![CDATA[<p>zhihu-crawler是一个基于Java的爬虫实战项目，主要功能是抓取知乎用户的基本资料，如果觉得不错，请给个star。<br><a id="more"></a></p><h2 id="爬取结果"><a href="#爬取结果" class="headerlink" title="爬取结果"></a>爬取结果</h2><ul><li>下图为爬取117w知乎用户数据的简单统计<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/wycm/zhihu-crawler/2.0/src/main/resources/img/zhihu-charts.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li>详细统计见 <a href="https://www.vwycm.cn/zhihu/charts" target="_blank" rel="noopener">https://www.vwycm.cn/zhihu/charts</a></li></ul><h2 id="工程导入-maven"><a href="#工程导入-maven" class="headerlink" title="工程导入(maven)"></a>工程导入(maven)</h2><ul><li>git clone <a href="https://github.com/wycm/zhihu-crawler" target="_blank" rel="noopener">https://github.com/wycm/zhihu-crawler</a> 克隆项目到本地</li><li><strong>eclipse</strong>导入步骤(eclipse_kepler版本，自带maven)，File-&gt;Import-&gt;Maven-&gt;Existing Maven Projects-&gt;选择刚刚clone的zhihu-crawler目录-&gt;导入成功</li><li><strong>idea</strong>导入步骤,File-&gt;Open-&gt;选择刚刚clone的zhihu-crawler目录-&gt;导入成功</li></ul><h2 id="工程导入-不使用maven"><a href="#工程导入-不使用maven" class="headerlink" title="工程导入(不使用maven)"></a>工程导入(不使用maven)</h2><ul><li>eclipse或myeclipse都可以</li><li>git clone <a href="https://github.com/wycm/zhihu-crawler" target="_blank" rel="noopener">https://github.com/wycm/zhihu-crawler</a> 克隆项目到本地</li><li>创建一个名字为zhihu-new-crawler（这个随便命名）的普通工程</li><li>拷贝刚刚clone的zhihu-crawler/src/main/java/com目录到zhihu-new-crawler/src目录下</li><li>右键工程-&gt;Build Path-&gt;Add External Archives…-&gt;导入zhihu-crawler/lib下的所有jar包</li><li>将zhihu-crawler/src/main/resources目录下的<a href="https://github.com/wycm/zhihu-crawler/blob/2.0/src/main/resources/config.properties" target="_blank" rel="noopener">config.properties</a>和<a href="https://github.com/wycm/zhihu-crawler/blob/2.0/src/main/resources/log4j.properties" target="_blank" rel="noopener">log4j.properties</a>拷贝至src目录下</li></ul><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>Run with <a href="https://github.com/wycm/zhihu-crawler/blob/2.0/src/main/java/com/crawl/Main.java" target="_blank" rel="noopener">Main.java</a> <br></p><h2 id="使用到的API"><a href="#使用到的API" class="headerlink" title="使用到的API"></a>使用到的API</h2><ul><li><p>地址(url)：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* 请求类型：GET</span><br><span class="line">* **请求参数**</span><br><span class="line"></span><br><span class="line">| 参数名 |类型 | 必填 | 值 | 说明|</span><br><span class="line">| :------------ | :------------ | :------------ | :----- | :------------ |</span><br><span class="line">| include | String | 是| ```data[*]answer_count,articles_count``` |需要返回的字段（这个值可以改根据需要增加一些字段，见如下示例url） |</span><br><span class="line">| offset  | int    | 是| 0 | 偏移量（通过调整这个值可以获取到一个用户的```所有关注用户```资料） |</span><br><span class="line">| limit   | int    | 是| 20 | 返回用户数（最大20，超过20无效） |</span><br><span class="line"></span><br><span class="line">* url示例：```https://www.zhihu.com/api/v4/members/wo-yan-chen-mo/followees?include=data[*].educations,employments,answer_count,business,locations,articles_count,follower_count,gender,following_count,question_count,voteup_count,thanked_count,is_followed,is_following,badge[?(type=best_answerer)].topics&amp;offset=0&amp;limit=20</span><br></pre></td></tr></table></figure></p></li><li><p>响应：json数据，会有关注用户资料</p></li><li><strong>注意</strong>：这个请求采用了oauth验证，需要在http header加上<code>authorization:oauth c3cef7c66a1843f8b3a9e6a1e3160e20</code>,这个值是存放在js文件中，详细获取方式见代码。</li></ul><h2 id="使用到的三方库"><a href="#使用到的三方库" class="headerlink" title="使用到的三方库"></a>使用到的三方库</h2><ul><li>HttpClient4.5-网络请求</li><li>Jsoup-html标签解析</li><li>JsonPath-json数据解析</li></ul><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul><li>大量使用http代理，突破同一个客户端访问量限制。</li><li>支持持久化(mysql),相关配置见<a href="https://github.com/wycm/zhihu-crawler/blob/2.0/src/main/resources/config.properties" target="_blank" rel="noopener">config.properties</a>。</li><li>多线程、爬取速度快。</li></ul><h2 id="持久化配置"><a href="#持久化配置" class="headerlink" title="持久化配置"></a>持久化配置</h2><ul><li>如果要持久化数据到mysql，先手动创建数据库，然后修改配置文件<a href="https://github.com/wycm/zhihu-crawler/blob/2.0/src/main/resources/config.properties" target="_blank" rel="noopener">config.properties</a>的如下属性。</li><li><code>db.enable = true</code></li><li><code>db.host =ip地址</code></li><li><code>db.username = 用户名</code></li><li><code>db.password = 密码</code></li><li><code>db.name = 数据库名</code></li></ul><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/wycm/zhihu-crawler/2.0/src/main/resources/img/zhihu-crawler-process.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h4 id="2016-12-26"><a href="#2016-12-26" class="headerlink" title="2016.12.26"></a>2016.12.26</h4><ul><li>移除未使用的包，修复ConcurrentModificationException和NoSuchElementException异常问题。</li><li>增加游客（免登录）模式抓取。</li><li>增加代理抓取模块。</li></ul><h4 id="2017-01-10"><a href="#2017-01-10" class="headerlink" title="2017.01.10"></a>2017.01.10</h4><ul><li>不再采用登录抓取，并移除登录抓取相关模块，模拟登录的主要逻辑代码见<a href="https://github.com/wycm/zhihu-crawler/blob/2.0/src/main/java/com/crawl/zhihu/ModelLogin.java" target="_blank" rel="noopener">ModelLogin.java</a>。</li><li>优化项目结构，加快爬取速度。采用ListPageThreadPool和DetailPageThreadPool两个线程池。ListPageThreadPool负责下载”关注用户“列表页，解析出关注用户，将关注用户的url去重，然后放到DetailPageThreadPool线程池。<br>DetailPageThreadPool负责下载用户详情页面，解析出用户基本信息并入库，获取该用户的”关注用户”的列表页url并放到ListPageThreadPool。</li></ul><h4 id="2017-01-17"><a href="#2017-01-17" class="headerlink" title="2017.01.17"></a>2017.01.17</h4><ul><li>增加代理序列化。</li><li>调整项目结构，大幅度提高爬取速度。不再使用ListPageThreadPool和DetailPageThreadPool的方式。直接下载关注列表页，可以直接获取到用户详细资料。</li></ul><h4 id="2017-03-30"><a href="#2017-03-30" class="headerlink" title="2017.03.30"></a>2017.03.30</h4><ul><li>知乎api变更，关注列表页不能获取到关注人数，导致线程池任务不能持续下去。抓取模式切换成原来ListPageThreadPool和DetailPageThreadPool的方式。</li></ul><h4 id="2017-05-26"><a href="#2017-05-26" class="headerlink" title="2017.05.26"></a>2017.05.26</h4><ul><li>修复代理返回错误数据，导致java.lang.reflect.UndeclaredThrowableException异常。</li></ul><h4 id="2017-11-05"><a href="#2017-11-05" class="headerlink" title="2017.11.05"></a>2017.11.05</h4><ul><li>知乎authorization文件更新，修改authorization获取方式。<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2></li><li>优化爬取速度</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li>想要爬取其它数据，如问题、答案等，完全可以在此基础上自己定制。</li><li>有问题的请提issue。</li><li>欢迎贡献代码。</li><li>爬虫交流群：633925314，欢迎交流。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;zhihu-crawler是一个基于Java的爬虫实战项目，主要功能是抓取知乎用户的基本资料，如果觉得不错，请给个star。&lt;br&gt;
    
    </summary>
    
      <category term="github" scheme="https://liujings8.github.io/categories/github/"/>
    
    
      <category term="black magic" scheme="https://liujings8.github.io/tags/black-magic/"/>
    
      <category term="fucking trick" scheme="https://liujings8.github.io/tags/fucking-trick/"/>
    
  </entry>
  
</feed>
